import math/rand;

!<<

import (
    "unsafe"
)

!>>

long hash_float(float n)
{
    if (n == 0.0f || n == -0.0f) {
        return 0;
    }
    !<<
    return int64(*(*uint32)(unsafe.Pointer(&l_n)))
    !>>
}

long hash_double(double n)
{
    if (n == 0.0 || n == -0.0) {
        return 0;
    }
    !<<
    return *(*int64)(unsafe.Pointer(&l_n))
    !>>
}

//一个随机的hash因子，主要用于每个进程计算hash值的随机化
//为避免初始化依赖引起问题，这个的赋值用native code在第一次用到的时候进行
final ulong rand_hash_factor = init_rand_hash_factor();

ulong init_rand_hash_factor()
{
    for (var i = 0; i < 100; ++ i)
    {
        var rhf = (ulong)rand.rand_n(LONG_MAX) * (ulong)rand.rand_n(LONG_MAX);
        if (rhf != 0)
        {
            return rhf;
        }
    }
    throw("运气不好？检查一下随机数产生器吧");
}

//通用的计算hash的方法，保证返回非负
public long hash<T>(T t)
{
    long h;

#use
    h = hash_double(t);
#oruse
    h = hash_float(t);
#oruse
    h = (long)t;
#oruse
    h = t.hash();
#enduse

    ulong uh = (ulong)h * 2862933555777941757UL;
    return (long)((uh >> 32) ^ uh ^ rand_hash_factor) & LONG_MAX;
}

public int cmp<T>(T a, T b)
{
#use
    return a.cmp(b);
#oruse
    if (a < b)
    {
        return -1;
    }
    if (a > b)
    {
        return 1;
    }
    return 0;
#enduse
}

public bool eq<T>(T a, T b)
{
#use
    return a.eq(b);
#oruse
    return a.cmp(b) == 0;
#oruse
    return a == b;
#enduse
}
