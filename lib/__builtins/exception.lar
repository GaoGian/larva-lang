//可以用throw函数抛出的对象类型
public interface Throwable
{
    public String to_str();
}

//抛出异常
public native void throw(Throwable t);

//捕获语法返回的对象：抛出的对象+traceback的组合
//定义：Catched<Throwable>是所有Catched对象的base
public class Catched<T>
{
    Catched(T t, String tb)
    {
        throwed = t;
        traceback = tb;
    }

    public void rethrow()
    {
        rethrow_catched(new Catched<Throwable>(throwed, traceback));
    }

    public T get_throwed()
    {
        return throwed;
    }

    public String get_traceback()
    {
        return traceback;
    }

    T throwed;
    String traceback;
}

//继续往上抛当前Catched对象，维持对象不变，即和再次throw的区别在于traceback可以保持不变
native void rethrow_catched(Catched<Throwable> c);

//assert函数
public void assert(bool b, String s)
{
    if (!b)
    {
        throw(new AssertError(s));
    }
}

//--------------------------------------------------------------------

/*
下面的catch相关的代码较为特殊，编译器会在代码生成阶段做一些特殊修改
主要原因在于：go规定recover必须在defer func中直接执行，即直接defer recover()或在defer func中调用的函数里用recover都无法捕获panic
因此必须在larva调用下面两个catch函数的时候，同时调用recover并将结果传进来，但语法上让程序员无感知
编译器的大致处理步骤就是在代码生成部分对这两个catch增加参数（定义和调用都需要调整），为了对代码实现影响最小，用了一个假的全局变量欺骗语法检查
相关trick代码元素都以下划线开头，以示区别
*/

Any _go_recovered;

native Catched<Throwable> _go_recovered_to_catched(Any _r);

//捕获base
public Catched<Throwable> catch_base(/*Any _go_recovered*/)
{
    return _go_recovered_to_catched(_go_recovered);
}

//捕获指定类型的异常
public Catched<T> catch<T>(/*Any _go_recovered*/)
{
    var c = _go_recovered_to_catched(_go_recovered);
    if (c == nil)
    {
        //无异常
        return nil;
    }
    T throwed = (T)c.get_throwed();
    if (throwed == nil)
    {
        //不是当前需要的类型，继续往上抛
        c.rethrow();
    }
    return new Catched<T>(throwed, c.get_traceback());
}

//---------------------------------------------------------------------

//一个基本的常用异常的实现：仅包含一个字符串info
public class Exception
{
    public Exception(String s)
    {
        info = s;
    }

    public String to_str()
    {
        return info;
    }

    String info;
}

//这里是通用的一些内建异常类型

//Assert错误，只用于assert
public class AssertError
{
    public AssertError(String s)
    {
        e = new Exception(s);
    }

    usemethod Exception e;
}

//索引（下标）错误，用于数组、Slice、Vector等可用下标定位元素的相关代码中
//数组的索引错误比较特殊，是根据go的panic转换的，没有idx信息
public class ArrayIndexError
{
    public String to_str()
    {
        return "";
    }
}
public class IndexError
{
    public IndexError(long i)
    {
        idx = i;
    }

    public String to_str()
    {
        return "%d".(idx);
    }

    long idx;
}

//下标范围错误，用于Slice、sub_str之类的取范围相关代码
public class RangeError
{
    public RangeError(long l, long b, long e)
    {
        len = l;
        begin = b;
        end = e;
    }

    public String to_str()
    {
        return "[%d][%d:%d]".(len, begin, end);
    }

    long len;
    long begin;
    long end;
}

//键错误，用于各种映射、集合等用到Key的地方，k为错误的键的字符串描述
public class KeyError
{
    public KeyError(String k)
    {
        e = new Exception(k);
    }

    usemethod Exception e;
}

//值错误，用于根据值解析、查找等操作的地方，v为错误的值的字符串描述
public class ValueError
{
    public ValueError(String v)
    {
        e = new Exception(v);
    }

    usemethod Exception e;
}
