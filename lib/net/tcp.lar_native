package LARVA_NATIVE

import (
    "net"
    "io"
)

type lar_cls_@<<_TcpListener>> struct {
    ntl *net.TCPListener
}

func lar_new_obj_lar_cls_@<<_TcpListener>>(addr *lar_cls_@<<:String>>) *lar_cls_@<<_TcpListener>> {
    tcp_addr, err := net.ResolveTCPAddr("tcp", lar_str_to_go_str(addr))
    if err != nil {
        lar_func_@<<:throw>>(&lar_cls_@<<Error>>{
            m_e: lar_new_obj_lar_cls_@<<_Error>>(err),
        })
    }
    ntl, err := net.ListenTCP("tcp", tcp_addr)
    if err != nil {
        lar_func_@<<:throw>>(&lar_cls_@<<Error>>{
            m_e: lar_new_obj_lar_cls_@<<_Error>>(err),
        })
    }
    return &lar_cls_@<<_TcpListener>>{ntl: ntl}
}

func (this *lar_cls_@<<_TcpListener>>) lar_method_addr() *lar_cls_@<<:String>> {
    return lar_str_from_go_str(this.ntl.Addr().String())
}

func (this *lar_cls_@<<_TcpListener>>) lar_method_accept() *lar_cls_@<<TcpConn>> {
    ntc, err := this.ntl.AcceptTCP()
    if err != nil {
        lar_func_@<<:throw>>(&lar_cls_@<<Error>>{
            m_e: lar_new_obj_lar_cls_@<<_Error>>(err),
        })
    }
    return &lar_cls_@<<TcpConn>>{
        m_tc: &lar_cls_@<<_TcpConn>>{
            ntc: ntc,
        },
    }
}

func (this *lar_cls_@<<_TcpListener>>) lar_method_close() {
    this.ntl.Close()
}

type lar_cls_@<<_TcpConn>> struct {
    ntc *net.TCPConn
}

func (this *lar_cls_@<<_TcpConn>>) lar_method_local_addr() *lar_cls_@<<:String>> {
    return lar_str_from_go_str(this.ntc.LocalAddr().String())
}

func (this *lar_cls_@<<_TcpConn>>) lar_method_remote_addr() *lar_cls_@<<:String>> {
    return lar_str_from_go_str(this.ntc.RemoteAddr().String())
}

func (this *lar_cls_@<<_TcpConn>>) lar_method_send(buf *lar_arr_uint8_1) {
    _, err := this.ntc.Write(buf.arr)
    if err != nil {
        lar_func_@<<:throw>>(&lar_cls_@<<Error>>{
            m_e: lar_new_obj_lar_cls_@<<_Error>>(err),
        })
    }
}

func (this *lar_cls_@<<_TcpConn>>) lar_method_recv(buf *lar_arr_uint8_1) int64 {
    recved_len, err := this.ntc.Read(buf.arr)
    if err != nil {
        if err == io.EOF {
            return 0
        }
        lar_func_@<<:throw>>(&lar_cls_@<<Error>>{
            m_e: lar_new_obj_lar_cls_@<<_Error>>(err),
        })
    }
    return int64(recved_len)
}

func (this *lar_cls_@<<_TcpConn>>) lar_method_close() {
    this.ntc.Close()
}
