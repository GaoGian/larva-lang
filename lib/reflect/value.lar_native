package LARVA_NATIVE

type lar_cls_@<<Value>> struct {
    lri lar_reflect_intf
}

func lar_new_obj_lar_cls_@<<Value>>(a lar_intf_@<<:Any>>) *lar_cls_@<<Value>> {
    return &lar_cls_@<<Value>>{
        lri: lar_reflect_gen_lri(a, false),
    }
}

func (this *lar_cls_@<<Value>>) lar_method_type() *lar_cls_@<<Type>> {
    //不通过new obj迂回，直接构造比较快
    return &lar_cls_@<<Type>>{
        lri: lar_reflect_gen_lri(this.lri.lar_reflect_zero_value(), false),
    }
}

func (this *lar_cls_@<<Value>>) lar_method_value() lar_intf_@<<:Any>> {
    return this.lri.lar_reflect_value()
}

func (this *lar_cls_@<<Value>>) lar_method_is_nil() bool {
    return this.lri.lar_reflect_is_nil()
}

func (this *lar_cls_@<<Value>>) lar_method_attr_at(idx int64) *lar_cls_@<<Ref>> {
    ptr, type_str := this.lri.lar_reflect_attr_ref_at(idx)
    if ptr == nil {
        lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<NoSuchAttr>>(idx, nil))
    }
    return &lar_cls_@<<Ref>>{
        ptr:      ptr,
        type_str: type_str,
    }
}

func (this *lar_cls_@<<Value>>) lar_method_attr_by_name(name *lar_cls_@<<:String>>) *lar_cls_@<<Ref>> {
    idx := this.lri.lar_reflect_attr_idx_by_name(name)
    if idx < 0 {
        lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<NoSuchAttr>>(idx, name))
    }
    return this.lar_method_attr_at(idx)
}
