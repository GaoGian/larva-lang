package LARVA_NATIVE

type lar_cls_@<<Type>> struct {
    lri lar_reflect_intf
}

func lar_new_obj_lar_cls_@<<Type>>(a lar_intf_@<<:Any>>) *lar_cls_@<<Type>> {
    return &lar_cls_@<<Type>>{
        lri: lar_reflect_gen_lri(a, true),
    }
}

func (this *lar_cls_@<<Type>>) lar_method_str() *lar_cls_@<<:String>> {
    return this.lri.lar_reflect_type_str()
}

func (this *lar_cls_@<<Type>>) lar_method_zero_value() lar_intf_@<<:Any>> {
    return this.lri.lar_reflect_zero_value()
}

func (this *lar_cls_@<<Type>>) lar_method_new_value(args *lar_arr_lar_intf_@<<:Any>>_1) lar_intf_@<<:Any>> {
    return this.lri.lar_reflect_new_value(args)
}

func (this *lar_cls_@<<Type>>) lar_method_is_array() bool {
    return this.lri.lar_reflect_is_array()
}

func (this *lar_cls_@<<Type>>) lar_method_is_obj() bool {
    return this.lri.lar_reflect_is_obj()
}

func (this *lar_cls_@<<Type>>) lar_method_attr_count() int64 {
    return this.lri.lar_reflect_attr_count()
}

func (this *lar_cls_@<<Type>>) lar_method_attr_idx_by_name(name *lar_cls_@<<:String>>) int64 {
    return this.lri.lar_reflect_attr_idx_by_name(name)
}

func (this *lar_cls_@<<Type>>) lar_method_attr_at(idx int64) *lar_cls_@<<AttrInfo>> {
    name, tag_map := this.lri.lar_reflect_attr_at(idx)
    if name == "" {
        return nil
    }
    return &lar_cls_@<<AttrInfo>>{
        m_of_type: this,
        m__name:   lar_str_from_go_str(name),
        m_tag_map: &lar_cls_@<<AttrTagMap>>{
            m: tag_map,
        },
    }
}

//---------------------------------------------------------------------------------------

type lar_cls_@<<AttrTagMap>> struct {
    m map[string]*lar_cls_@<<:String>>
}

func (this *lar_cls_@<<AttrTagMap>>) lar_method_get(tag_name *lar_cls_@<<:String>>) *lar_cls_@<<:String>> {
    return this.m[lar_str_to_go_str(tag_name)]
}
