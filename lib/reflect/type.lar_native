package LARVA_NATIVE

type lar_cls_@<<Type>> struct {
    lri lar_reflect_intf
}

func lar_new_obj_lar_cls_@<<Type>>(a lar_intf_@<<:Any>>) *lar_cls_@<<Type>> {
    return &lar_cls_@<<Type>>{
        lri: lar_reflect_gen_lri(a, true),
    }
}

func (this *lar_cls_@<<Type>>) lar_method_str() *lar_cls_@<<:String>> {
    return this.lri.lar_reflect_type_str()
}

func (this *lar_cls_@<<Type>>) lar_method_zero_value() lar_intf_@<<:Any>> {
    return this.lri.lar_reflect_zero_value()
}

func (this *lar_cls_@<<Type>>) lar_method_new_value(args *lar_arr_lar_intf_@<<:Any>>_1) lar_intf_@<<:Any>> {
    return this.lri.lar_reflect_new_value(args)
}

func (this *lar_cls_@<<Type>>) lar_method_is_array() bool {
    return this.lri.lar_reflect_is_array()
}

func (this *lar_cls_@<<Type>>) lar_method_is_obj() bool {
    return this.lri.lar_reflect_is_obj()
}

//---------------------------------------------------------------------------------------

type lar_cls_@<<AttrTagMap>> struct {
    m map[string]*lar_cls_@<<:String>>
}

func (this *lar_cls_@<<AttrTagMap>>) lar_method_get(tag_name *lar_cls_@<<:String>>) *lar_cls_@<<:String>> {
    return this.m[lar_str_to_go_str(tag_name)]
}
