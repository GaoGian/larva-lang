package LARVA_NATIVE

import (
    "reflect"
    "strings"
)

//type lar_reflect_intf interface
//lar_reflect_intf的定义放在__builtin的util.lar_native中，因为比较基础，runtime和__builtins可能需要

//从对象获取lri，reflect的Type和Value其实都是对lri的封装，分别使用lri中的一部分接口，区别在于Type的lri尽量用zero_value，避免引用大对象
func lar_reflect_gen_lri(a lar_intf_@<<:Any>>, need_zero_value bool) lar_reflect_intf {
    lri, ok := lar_reflect_try_gen_base_type_lri(a, need_zero_value)
    if ok {
        return lri
    }

    lri, ok = a.(lar_reflect_intf)
    if !ok {
        lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<NotLarvaObjectError>>())
    }
    if need_zero_value {
        return lri.lar_reflect_zero_value().(lar_reflect_intf) //这里肯定能转成功，不需要判断了
    }
    return lri
}

//反射中的赋值的目标变量的相关信息
type lar_reflect_stru_assign_dst struct {
    ptr      interface{} //被赋值的变量的指针
    type_str string      //被赋值的变量的类型名，若为函数的ref参数，则前面有‘ref ’
}

func lar_reflect_try_assign_to_obj_type(v lar_intf_@<<:Any>>, dst *lar_reflect_stru_assign_dst) bool {
    v_value := reflect.ValueOf(v)
    dst_ptr_elem_value := reflect.ValueOf(dst.ptr).Elem()
    dst_ptr_elem_type := dst_ptr_elem_value.Type()
    if v_value.Type().ConvertibleTo(dst_ptr_elem_type) {
        dst_ptr_elem_value.Set(v_value.Convert(dst_ptr_elem_type))
        return true
    }
    return false
}

//根据反射赋值规则，将v赋值给dst表示的变量
func lar_reflect_assign(idx int64, v lar_intf_@<<:Any>>, dst *lar_reflect_stru_assign_dst) {
    //若目标变量是基础类型，则采用基础类型的规则赋值
    ok, is_obj := lar_reflect_try_assign_to_base_type(v, dst)
    if ok {
        //赋值成功
        return
    }
    if !is_obj {
        //赋值失败
        lar_func_@<<:throw>>(
            lar_new_obj_lar_cls_@<<AssignError>>(int64(idx), lar_reflect_any_to_type_str(v), lar_str_from_go_str(dst.type_str)))
    }

    //目标变量是对象类型，先看v有没有实现as_default接口，若有则优先使用其返回值，否则用原值
    //然后用go的reflect对v做convert后赋值
    //理论上讲，如果目标类型不是larva的类型，这里可能会有问题，不过dst的值都是编译器自己生成的代码初始化的，所以不检查问题也不大
    if as_default_intf, ok := v.(interface {lar_method_as_default() lar_intf_@<<:Any>>}); ok {
        ok = lar_reflect_try_assign_to_obj_type(as_default_intf.lar_method_as_default(), dst)
        if ok {
            return
        }
    }
    ok = lar_reflect_try_assign_to_obj_type(v, dst)
    if ok {
        return
    }
    lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<AssignError>>(int64(idx), lar_reflect_any_to_type_str(v), lar_str_from_go_str(dst.type_str)))
}

//将args中的value按反射赋值的规则，赋值给assign_dsts中对应位置的被赋值变量
func lar_reflect_assign_args(args *lar_arr_lar_intf_@<<:Any>>_1, assign_dsts []lar_reflect_stru_assign_dst) {
    var args_arr []lar_intf_@<<:Any>>
    if args != nil {
        args_arr = args.arr
    }

    //先检查参数数量是否匹配
    arg_count := len(args_arr)
    need_count := len(assign_dsts)
    if arg_count != need_count {
        lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<ArgCountError>>(int64(arg_count), int64(need_count)))
    }

    //逐个进行赋值
    for idx, v := range args_arr {
        dst := &assign_dsts[idx]
        if strings.HasPrefix(dst.type_str, "ref ") {
            //若dst类型是ref参数，则v必须是一个reflect.Ref类型，需要将v进一步解析，然后严格匹配，必须完全一致
            ref_v, ok := v.(*lar_cls_@<<Ref>>)
            if !ok {
                lar_func_@<<:throw>>(
                    lar_new_obj_lar_cls_@<<AssignError>>(int64(idx), lar_reflect_any_to_type_str(v), lar_str_from_go_str(dst.type_str)))
            }
            v_ptr_value := reflect.ValueOf(ref_v.ptr)
            dst_ptr_elem_value := reflect.ValueOf(dst.ptr).Elem()
            if v_ptr_value.Type() != dst_ptr_elem_value.Type() {
                v_type_str := "ref " + lar_go_func_any_to_type_str(v_ptr_value.Elem().Interface())
                lar_func_@<<:throw>>(
                    lar_new_obj_lar_cls_@<<AssignError>>(int64(idx), lar_str_from_go_str(v_type_str), lar_str_from_go_str(dst.type_str)))
            }
            dst_ptr_elem_value.Set(v_ptr_value)
        } else {
            //若dst类型不是ref参数，则按照反射赋值规则对v分情况进行处理后赋值
            lar_reflect_assign(int64(idx), v, dst)
        }
    }
}

func lar_reflect_raise_no_such_method(idx int64, method_name *lar_cls_@<<:String>>) {
    lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<NoSuchMethod>>(idx, method_name))
    panic("unreachable")
}
