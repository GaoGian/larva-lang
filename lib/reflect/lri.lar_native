package LARVA_NATIVE

//这里定义了各种基础对象到lri的封装

//base定义了公共的一些方法，大部分是对不支持的接口抛异常
//只被基础对象的lri封装结构匿名包含，因为非基础类型的对象可以为nil，调用匿名包含的struct的方法会panic

type lar_reflect_lri_base struct {
}

func (base *lar_reflect_lri_base) lar_reflect_new_value(args *lar_arr_lar_intf_@<<:Any>>_1) lar_intf_@<<:Any>> {
    lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<UnsupportedOper>>())
    panic("unreachable")
}

func (base *lar_reflect_lri_base) lar_reflect_is_array() bool {
    return false
}

func (base *lar_reflect_lri_base) lar_reflect_is_obj() bool {
    return false
}

func (base *lar_reflect_lri_base) lar_reflect_is_nil() bool {
    return false
}

func (base *lar_reflect_lri_base) lar_reflect_attr_count() int64 {
    lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<UnsupportedOper>>())
    panic("unreachable")
}

func (base *lar_reflect_lri_base) lar_reflect_attr_idx_by_name(name *lar_cls_@<<:String>>) int64 {
    lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<UnsupportedOper>>())
    panic("unreachable")
}

func (base *lar_reflect_lri_base) lar_reflect_attr_at(idx int64) (string, map[string]*lar_cls_@<<:String>>) {
    lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<UnsupportedOper>>())
    panic("unreachable")
}

func (base *lar_reflect_lri_base) lar_reflect_attr_ref_at(idx int64) (interface{}, string) {
    lar_func_@<<:throw>>(lar_new_obj_lar_cls_@<<UnsupportedOper>>())
    panic("unreachable")
}

//----------------------------------------------------------------------

//nil intf

type lar_reflect_lri_nil_intf struct {
    lar_reflect_lri_base
}

var lar_reflect_type_str_nil_intf = lar_str_from_go_str("nil")

func (this *lar_reflect_lri_nil_intf) lar_reflect_type_str() *lar_cls_@<<:String>> {
    return lar_reflect_type_str_nil_intf
}

func (this *lar_reflect_lri_nil_intf) lar_reflect_zero_value() lar_intf_@<<:Any>> {
    return nil
}

func (this *lar_reflect_lri_nil_intf) lar_reflect_value() lar_intf_@<<:Any>> {
    return nil
}
