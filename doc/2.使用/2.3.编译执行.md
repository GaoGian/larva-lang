# **编译执行**

本节将通过一个简单的‘hello world’示例来说明使用Larva开发、编译和执行的过程

## **环境准备**

根据前述环境需求准备好运行平台，并安装、配置好Python2和Golang的开发环境，需要注意的是Golang的go命令所在的目录必须加入环境变量PATH，
即保证可直接通过go命令来执行，因为编译器会调用它

## **安装Larva**

从Larva项目地址通过git clone或直接下载的方式将整个项目下载至本地，可存储在任意位置，为文档描述方便起见，假设项目目录为‘~/dev/larva-lang’

## **开发程序**

如前所述，一个Larva程序由内建模块、主模块和其所直接或间接依赖的其他模块组成，因此开发一个程序就是开发必要模块的过程

以开发一个简单的‘hello world’程序为例，这个程序本身需要一个主模块，我们将其命名为`hello_world`
1. 在适当的位置建立它的目录，假设为‘~/lar_test/hello_world’
2. 在主模块目录下建立代码文件开始开发，例如‘~/lar_test/hello_world/hello_world.lar’
3. 编辑这个代码文件，录入代码：
    ```
    public void main()
    {
        println("hello world");
    }
    ```
    *Note*：代码的语法含义解释不在本节内容范围，只需要知道上述代码是一个打印出‘hello world’的程序即可（严格说是这个程序的主模块）

## **编译执行**

1. 进入目录‘~/lar_test’，即主模块所在目录

2. 执行命令：
    ```
    python ~/dev/larva-lang/compiler/larc.py --module_path=. hello_world
    ```
    命令执行成功后，可看到主模块同级目录下生成了一个新目录‘~/lar_test/hello_world.lar_out’，即程序的lar_out目录，lar_out目录下有两项：
    * 一个可执行程序‘hello_world’，即编译结果，直接执行即可如期望打印出‘hello world’
    * 一个目录‘src’，存放这个程序的Golang目标代码，包括两项：
        * 一个目录，程序的所有Larva模块的编译结果都在这个目录中，这个目录本身也是一个Golang的package，
        也就是说整个一个Larva程序会被编译为一个Golang的package，Larva级别的模块只是在编译过程做区分。这个Golang package会有一个引导函数，
        用于初始化程序环境并调用Larva的main函数的编译结果
        * 一个引导程序的go文件，即Golang程序的`package main`，内容很简单，直接调用上面说的引导函数来启动程序，
        并通过`os.Exit`返回Larva的main函数的返回结果

3. 运行程序，直接执行‘~/lar_test/hello_world.lar_out/hello_world’即可看到执行结果

* 这里为了描述清晰，将编译和执行过程分开成两个步骤，在编译阶段加上`--run`参数，即可对一个程序进行编译+执行的批处理操作，在开发调试中会比较方便。
建议可以自己在环境变量PATH中合适的目录下建立一个shell脚本‘larva’，内容为：
    ```
    python ~/dev/larva-lang/compiler/larc.py --module_path=. --run $1
    ```
    如此便可很方便地通过这个脚本对程序进行编译和执行，例如：
    ```
    larva hello_world
    ```
    简单起见，后续文档中默认以这种方式描述编译执行过程

* 主模块和其他模块一样，也可以是多级的，例如上述例子也可这样进行：
    1. 进入目录‘~’
    2. 执行命令
        ```
        larva lar_test/hello_world
        ```
        可以看到依然是建立了目录‘~/lar_test/hello_world.lar_out’并可正常执行，但这时候在程序内部主模块的全名变成了`lar_test/hello_world`

## **模块查找规则**

如前所述，Larva在编译的时候从内建模块和主模块开始，逐步收集完成程序的模块集合并进行编译，在这个过程中，需要通过模块全名来找到其代码所在位置，
规则：
* 编译或编译执行程序时必须指定`--module_path`参数，参数值为一个路径列表，例如`.:../my_lib:~/other_lib`
* 编译器启动时，根据自身所在目录定位到标准库目录路径
* 查找一个模块时，先到标准库目录查找，若没有则按照`--module_path`参数指定的列表进行查找，直到找到为止，如果所有路径下都找不到，则报错
* 多级的模块名在查找时作为多级目录来解释，相对路径名的模块导入规则请参考第三章import语法的文档

### ***Note***

Larva将标准库作为查找路径第一位，这个做法和很多其他语言不太一样，其他语言一般采用程序员定义优先的设计，可以实现自定义库覆盖标准库，更加灵活

Larva不这么做的原因是我不希望提供覆盖标准库的做法，例如有人自己实现一个名为time的库，覆盖了标准库，虽然可以更加灵活，
但是在代码阅读和维护上可能会带来很多问题

当然，Larva的这个设计相当于也规定了用户自定义的模块是不能和标准库冲突的，否则无法被编译器定位到，这看上去有些不方便，
但由于Larva支持多级模块全名，相对来说问题也不是那么大：
* 标准库会将库分类管理，尽量收敛一级模块目录的数量
* 用户自定义库需要自己规划好，用多级目录划分开
* 目前阶段标准库的结构还比较随意，后面会做进一步整理，并尽量参考其他流行语言，给出一个合理结构
