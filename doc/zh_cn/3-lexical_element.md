词法元素
================
本文说明larva代码中词法相关的元素表示

编码
----
larva代码（包括.lar和.lar_ext模块）必须用ascii或兼容ascii的编码格式书写，且不可出现ascii控制字符（0到31号字符）

在每个代码文件头第一行可指定文件编码，larva编译器提取编码采用正则：
``#.*coding[=:]\s*([-\w.]+)``，
如此规定的原因是可兼容Emacs或VIM的相关语法，方便编辑

或者可以用utf8的bom头来指定utf8编码，这种情况下文件编码默认为utf8，
若此时又使用上述#coding语法指定编码，则编译器会忽略#coding这一行，并给出警告信息

如不指定编码信息，则默认为ascii

编码的指定只是说明当前代码文件，每个模块可以用不同的编码书写并分别指定

关键字
------
if elif else while return break continue for in not and or nil print func
import global true false pass lambda class this super extends int export

物理行和逻辑行
--------------
物理行是指在源码中以回车结尾的行，逻辑行是指具有完整逻辑意义的一行，一个逻辑行可折行为多个物理行，
对于较长的逻辑行建议折行。

larva用括号匹配实现折行，即若一个物理行结束时，存在未匹配的括号，则认为折行，例如::

    a = (1 + 2
    * 3 / 4 %
    5)

这三个物理行表示一个逻辑行a=(1+2*3/4%5)

注释
----
larva的注释分单行注释和多行注释，单行注释符号为//或#，从符号开始到当前物理行结束为一个注释，会被编译器忽略。
多行注释用/\*和\*/包围，可跨多行，编译器也会忽略。

空白字符
--------
除回车换行（CRLF）外，larva的空白字符还包括空格和tab符号

空行
----
无字符或只含空白字符的行为空行，会被编译器忽略

缩进
----
一个逻辑行的前导空白（空格和tab符号）是这个逻辑行的缩进，缩进是larva语法的一部分，用于区分代码块，连续的有相同缩进长度的逻辑行组成一个代码块

缩进长度用空格数量来计算，如存在tab符号，则此tab换算为一定数量的空格，计算规则为：从左到右替换，每个tab从它所在的缩进位置向前到最近一个8的整数倍的位置。
例如，“tabtab空格”缩进长度为8+8+1=17，“空格空格tab”缩进长度为1+1+6=8，以此类推。如此规定是为了和UNIX平台环境一致

**建议**：一律使用四个空格来进行缩进，不要用tab，这和其他语言的流行规定也是一致的

每个代码块的缩进长度必须大于其所在的上层代码块，如::

    if a == 0:
        if b == 0:
            print "hello" //if b == 0控制的块
        print "world" //和if b == 0同级
    print "end" //和if a == 0同级

以下缩进是错误的::

    if a == 0:
        if b == 0:
        print "hello" //if开启了一个新代码块，需要更大的缩进长度
      print "world" //前面的逻辑行中找不到同级的上层代码块

除逻辑行区分的回车和缩进的空白字符外，token之间的其他空白字符或行尾空白都将被忽略，可自由使用以调整代码样式

空行和单行注释不计算缩进，无需保证和所在块同级::

    while true:
    //注释无需考虑缩进
        print "hello"
                    //空白到这里的空行也没关系
        print "world"

多行注释情况复杂一点，如果多行注释独立存在，没有内嵌到逻辑行，则无需考虑，若内嵌到逻辑行开头，则前导缩进有效::

    while true:
      /*独立多行注释，缩进随意*/
        print "hello" /*内嵌到逻辑行但不是开头，自然没有缩进相关问题*/
        /*内嵌到逻辑行开头，缩进有效，后面这个print的缩进就是这个注释前面的缩进长度*/ print "world"
        /*跨行注释
     跨行注释内部不用考虑缩进问题，
        但强烈建议
        和当前块缩进一致，排版美观*/

**强烈建议**：注释不要在逻辑行开头，独立于逻辑行的注释缩进和所在代码块严格一致，跨行注释则根据当前代码块排版

标识符（名字）
--------------
标识符用于类名、变量名、函数名、模块名等可自定义的名字，格式：``[A-Za-z_][A-Za-z_0-9]*``，但不能用上述关键字

标识符长度无限制，大小写敏感

特殊标识符
----------

    #. 类的方法若以双下划线开头和结尾，则其名字必须是固定的内建方法之一，且在类的方法定义和调用中，larva编译器会做特殊处理，若用于类外则当普通标识符处理，内建方法详细描述见类相关的文档

字面量
------
larva有五种字面量常量

:int
    整数字面量，larva的int是二进制补码方式表示的64位有符号整数，范围-2^63~2^63-1。可有多种表示方式：
    
        #. 十进制表示，字符串“0”，或非0开头的0-9数字序列
        #. 二进制表示，0b开头的0-1数字序列
        #. 八进制表示，0或0o开头的0-7数字序列
        #. 十六进制表示，0x开头的0-9A-Fa-f的字符序列

    如为十进制表示，则int字面量范围需要是0~2^63-1，如为其他进制表示，则范围是0~2^64-1，超出2^63-1的值自动转为对应的负数，
    这样设计是因为其他三种进制的字面量常用于位运算，较为直观
    
    如int字面量超出规定范围，则编译报错

:long
    长整数字面量，larva的长整数是二进制补码表示的高精度整数，表示方式和上述int字面量类似，两点区别：

        #. 末尾加L后缀，说明是long（为避免和数字‘1’混淆，禁止用小写的‘l’）
        #. 值范围视具体实现而定，参考long类型相关文档

:float
    浮点数字面量，larva的浮点数是双精度浮点数，范围参考IEEE754标准，表示方式和流行语言相同，如::

        3.14    10.    .001    1e100    3.14e-10    0e0

    均为合法浮点数字面量

    如float字面量超出规定范围，则编译报错

:str
    字符串字面量，larva的字符串是16位unicode序列，str字面量由单引号''或双引号""括起来均可，不可跨行。
    字符串中以‘\\’开头的为换码序列，具体规定见下述。除换码序列外，其他内容会根据当前文件编码解码为16位unicode序列

    每个字符串字面量算作一个token，多个连续的字符串字面量会被自动合并，如："abc" "def" "123"会被合并为"abcdef123"

:byte
    字节串字面量，larva的字节串是8位字节序列，字节串字面量由b""或b''括起来均可，不可跨行。
    byte字面量中只允许出现ascii字符和非unicode换码序列
    
    每个byte字面量算作一个token，多个连续的byte字面量会被自动合并，但str和byte不可并列写，因为无法合并

:换码序列
    str或byte的字面量中可用‘\\’换码，有如下换码序列（ascii控制码请参考相关专业文档）：

        #. \\\\，\\'，\\"，表示\\，'，"三种字符
        #. \\a，ascii控制码，bel
        #. \\b，ascii控制码，backspace
        #. \\f，ascii控制码，formfeed
        #. \\n，换行符
        #. \\r，回车符
        #. \\t，制表符
        #. \\v，ascii控制码，vertical tab
        #. \\ooo，ooo为1到3位八进制数，表示对应编号的字符或字节，范围0~377
        #. \\xHH，HH为两位十六进制数，表示对应编号的字符或字节，范围00~FF
        #. \\uHHHH，HHHH为四位十六进制数，表示16位unicode字符，范围0000~FFFF
        #. \\UHHHHHHHH，HHHHHHHH为八位十六进制数，表示32位unicode字符，范围参考unicode标准，一般是00000000~0010FFFF

符号
----
这里的符号包括运算符和分隔符，具体语法含义见后面的文档

~ % ^ & * ( ) - + = | { } [ ] : " ' < , > / . b" b' != == <<= << <= >>>= >>> >>= >> >=
%= ^= &= \*= -= += \|= /=
